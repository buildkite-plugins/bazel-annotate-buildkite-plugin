#!/usr/bin/env python3
"""
Bazel BEP Failure Analyzer - Standalone Binary

This is a standalone version that can be used directly without Bazel build system.
Uses proper protobuf parsing for more accurate failure detection.
"""

import argparse
import sys
import os
import struct
from typing import List, Dict, Any, Optional
from pathlib import Path
import subprocess

try:
    from google.protobuf.message import DecodeError
    from google.protobuf.json_format import MessageToDict
    import google.protobuf.message
    PROTOBUF_AVAILABLE = True
except ImportError:
    PROTOBUF_AVAILABLE = False


class BEPAnalyzer:
    """Analyzes Bazel Build Event Protocol protobuf files for failures."""
    
    # Memory usage limits
    MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB max BEP file size
    MAX_FAILURES = 50  # Maximum number of failures to collect
    MAX_MESSAGE_SIZE = 5000  # Maximum size of individual failure messages
    MAX_ERROR_LINES = 10  # Maximum lines per error message
    MAX_STRINGS_PER_EVENT = 20  # Maximum strings to extract per protobuf event
    MAX_VARINT_BYTES = 10  # Maximum bytes for protobuf varint (per specification)
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.failures = []
        self.failures_skipped = 0  # Track skipped failures due to limits
        
    def extract_failures(self, bep_file_path: str) -> List[Dict[str, Any]]:
        """Extract failure information from a BEP protobuf file."""
        failures = []
        
        # Check file size before processing
        try:
            file_size = os.path.getsize(bep_file_path)
            if file_size > self.MAX_FILE_SIZE:
                if self.verbose:
                    print(f"‚ö†Ô∏è  Warning: BEP file is large ({file_size / (1024*1024):.1f}MB), "
                          f"processing may be slow or limited")
        except OSError:
            pass  # Continue if we can't get file size
        
        try:
            bytes_processed = 0
            with open(bep_file_path, 'rb') as f:
                while len(failures) < self.MAX_FAILURES:
                    # Read varint-delimited protobuf messages
                    message_data = self._read_varint_delimited_message(f)
                    if not message_data:
                        break
                    
                    bytes_processed += len(message_data)
                    
                    # Stop processing if file is too large and we have some failures
                    if bytes_processed > self.MAX_FILE_SIZE and failures:
                        if self.verbose:
                            print(f"‚ö†Ô∏è  Stopping processing due to file size limit")
                        break
                    
                    # Parse the message for failure events
                    failure = self._parse_build_event_for_failure(message_data)
                    if failure:
                        failures.append(failure)
                        if self.verbose:
                            print(f"üîç Found failure: {failure.get('target', 'Unknown')}")
                
                # Check if we hit the failure limit
                if len(failures) >= self.MAX_FAILURES:
                    # Count remaining failures without collecting them
                    while True:
                        message_data = self._read_varint_delimited_message(f)
                        if not message_data:
                            break
                        failure = self._parse_build_event_for_failure(message_data)
                        if failure:
                            self.failures_skipped += 1
                        
        except Exception as e:
            if self.verbose:
                print(f"Warning: Error reading BEP file: {e}")
        
        # Report if we hit limits
        if self.failures_skipped > 0 and self.verbose:
            print(f"‚ö†Ô∏è  Skipped {self.failures_skipped} additional failures due to limit ({self.MAX_FAILURES})")
            
        return failures
    
    def _read_varint_delimited_message(self, f) -> Optional[bytes]:
        """Read a varint-delimited protobuf message from file."""
        # Read the varint length
        length = self._read_varint(f)
        if length is None:
            return None
            
        # Read the message data
        message_data = f.read(length)
        if len(message_data) != length:
            return None
            
        return message_data
    
    def _read_varint(self, f) -> Optional[int]:
        """Read a varint from file.
        
        Protobuf varints are at most 10 bytes as per specification:
        https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.coded_stream/
        """
        max_bytes = self.MAX_VARINT_BYTES
        value = 0
        shift = 0
        bytes_read = 0
        
        while bytes_read < max_bytes:
            byte_data = f.read(1)
            if not byte_data:
                return None
                
            bytes_read += 1
            byte = byte_data[0]
            value |= (byte & 0x7F) << shift
            
            if (byte & 0x80) == 0:
                break
                
            shift += 7
            if shift >= 64:
                return None
        
        # If we've read max_bytes and still haven't found the end, it's malformed
        if bytes_read >= max_bytes:
            if self.verbose:
                print(f"Warning: Malformed varint detected (>{max_bytes} bytes)")
            return None
                
        return value
    
    def _parse_build_event_for_failure(self, message_data: bytes) -> Optional[Dict[str, Any]]:
        """Parse a build event message for failure information using protobuf."""
        if PROTOBUF_AVAILABLE:
            return self._parse_protobuf_event(message_data)
        else:
            # Fallback to string parsing
            return self._parse_string_event(message_data)
    
    def _parse_protobuf_event(self, message_data: bytes) -> Optional[Dict[str, Any]]:
        """Parse BEP event using protobuf parsing."""
        try:
            # Since we don't have the compiled protobuf classes, we'll use a hybrid approach
            # Parse key protobuf fields manually for common failure patterns
            event_dict = self._decode_protobuf_to_dict(message_data)
            
            if not event_dict:
                return None
                
            # Check for ActionExecuted events with failures
            if 'action' in event_dict:
                action = event_dict['action']
                if not action.get('success', True) or action.get('exit_code', 0) != 0:
                    return self._extract_action_failure(event_dict, action)
            
            # Check for TargetComplete events with failures
            if 'completed' in event_dict:
                completed = event_dict['completed']
                if not completed.get('success', True):
                    return self._extract_target_failure(event_dict, completed)
            
            # Check for TestResult events with failures
            if 'test_result' in event_dict:
                test_result = event_dict['test_result']
                status = test_result.get('status', 'NO_STATUS')
                if status in ['FAILED', 'TIMEOUT', 'FAILED_TO_BUILD', 'REMOTE_FAILURE']:
                    return self._extract_test_failure(event_dict, test_result)
            
            # Check for Aborted events
            if 'aborted' in event_dict:
                return self._extract_aborted_failure(event_dict)
                
        except Exception as e:
            if self.verbose:
                print(f"Warning: Error parsing protobuf message: {e}")
                
        return None
    
    def _decode_protobuf_to_dict(self, message_data: bytes) -> Optional[Dict[str, Any]]:
        """Decode protobuf message to dictionary format."""
        try:
            # Use a simple protobuf field decoder to extract key information
            # This is a simplified implementation that looks for common patterns
            result = {}
            
            # Look for string fields that might contain labels, paths, etc.
            strings = self._extract_protobuf_strings(message_data)
            
            # Check for common failure indicators in the binary data
            if b'action' in message_data and (b'success' in message_data or b'exit_code' in message_data):
                result['action'] = {
                    'success': b'\x08\x00' not in message_data,  # success=false in protobuf
                    'exit_code': self._extract_exit_code(message_data)
                }
                
            if b'completed' in message_data and b'success' in message_data:
                result['completed'] = {
                    'success': b'\x08\x00' not in message_data
                }
                
            if b'test_result' in message_data:
                result['test_result'] = {
                    'status': self._extract_test_status(message_data)
                }
                
            if b'aborted' in message_data:
                result['aborted'] = {
                    'reason': self._extract_abort_reason(message_data)
                }
            
            # Add extracted strings for context
            if strings:
                result['_strings'] = strings
                
            return result if result else None
            
        except Exception as e:
            if self.verbose:
                print(f"Warning: Error decoding protobuf: {e}")
            return None
    
    def _extract_protobuf_strings(self, data: bytes) -> List[str]:
        """Extract readable strings from protobuf data."""
        strings = []
        i = 0
        while i < len(data) - 4 and len(strings) < self.MAX_STRINGS_PER_EVENT:
            # Look for length-prefixed strings (common in protobuf)
            if data[i] & 0x80 == 0:  # Single byte length
                length = data[i]
                if 1 <= length <= 200 and i + 1 + length <= len(data):
                    try:
                        string_data = data[i+1:i+1+length]
                        text = string_data.decode('utf-8')
                        if self._is_meaningful_string(text):
                            strings.append(text)
                    except UnicodeDecodeError:
                        pass
            i += 1
        return strings
    
    def _is_meaningful_string(self, text: str) -> bool:
        """Check if a string contains meaningful information."""
        if len(text) < 3 or len(text) > 500:
            return False
        # Look for target labels, file paths, error messages
        meaningful_patterns = [
            '//',  # Bazel target
            '.cc', '.cpp', '.h', '.py', '.java',  # File extensions
            'error', 'failed', 'Error', 'Failed',  # Error indicators
            'BUILD', 'WORKSPACE',  # Build files
        ]
        return any(pattern in text for pattern in meaningful_patterns)
    
    def _extract_exit_code(self, data: bytes) -> int:
        """Extract exit code from protobuf data."""
        # Look for exit_code field (typically field 2 in ActionExecuted)
        for i in range(len(data) - 4):
            if data[i:i+2] == b'\x10':  # Field 2, varint
                # Next byte(s) contain the exit code
                if i + 2 < len(data):
                    return data[i + 2] if data[i + 2] < 128 else 0
        return 0
    
    def _extract_test_status(self, data: bytes) -> str:
        """Extract test status from protobuf data."""
        status_map = {
            0: 'NO_STATUS', 1: 'PASSED', 2: 'FLAKY', 3: 'TIMEOUT',
            4: 'FAILED', 5: 'INCOMPLETE', 6: 'REMOTE_FAILURE', 7: 'FAILED_TO_BUILD'
        }
        # Look for status field (typically field 5 in TestResult)
        for i in range(len(data) - 2):
            if data[i] == 0x28:  # Field 5, varint
                if i + 1 < len(data):
                    status_code = data[i + 1] if data[i + 1] < 128 else 0
                    return status_map.get(status_code, 'UNKNOWN')
        return 'NO_STATUS'
    
    def _extract_abort_reason(self, data: bytes) -> str:
        """Extract abort reason from protobuf data."""
        abort_reasons = {
            1: 'USER_INTERRUPTED', 2: 'TIME_OUT', 3: 'REMOTE_ENVIRONMENT_FAILURE',
            4: 'INTERNAL', 5: 'LOADING_FAILURE', 6: 'ANALYSIS_FAILURE'
        }
        # Look for reason field in Aborted message
        for i in range(len(data) - 2):
            if data[i] == 0x08:  # Field 1, varint
                if i + 1 < len(data):
                    reason_code = data[i + 1] if data[i + 1] < 128 else 0
                    return abort_reasons.get(reason_code, 'UNKNOWN')
        return 'UNKNOWN'
    
    def _extract_action_failure(self, event_dict: Dict, action: Dict) -> Dict[str, Any]:
        """Extract failure details from ActionExecuted event."""
        failure = {
            'type': 'build_failure',
            'status': 'COMPILATION_FAILED' if action.get('exit_code', 0) != 0 else 'BUILD_FAILED',
            'target': self._find_target_label(event_dict),
            'message': '',
            'file_location': None,
            'line_number': None,
            'exit_code': action.get('exit_code', 0)
        }
        
        # Try to extract error details from strings
        strings = event_dict.get('_strings', [])
        failure['message'] = self._extract_error_message_from_strings(strings)
        failure['file_location'], failure['line_number'] = self._extract_file_location_from_strings(strings)
        
        return failure
    
    def _extract_target_failure(self, event_dict: Dict, completed: Dict) -> Dict[str, Any]:
        """Extract failure details from TargetComplete event."""
        return {
            'type': 'build_failure',
            'status': 'BUILD_FAILED',
            'target': self._find_target_label(event_dict),
            'message': 'Target build failed',
            'file_location': None,
            'line_number': None
        }
    
    def _extract_test_failure(self, event_dict: Dict, test_result: Dict) -> Dict[str, Any]:
        """Extract failure details from TestResult event."""
        return {
            'type': 'test_failure',
            'status': test_result.get('status', 'TEST_FAILED'),
            'target': self._find_target_label(event_dict),
            'message': f"Test failed with status: {test_result.get('status', 'UNKNOWN')}",
            'file_location': None,
            'line_number': None
        }
    
    def _extract_aborted_failure(self, event_dict: Dict) -> Dict[str, Any]:
        """Extract failure details from Aborted event."""
        aborted = event_dict['aborted']
        return {
            'type': 'build_failure',
            'status': 'BUILD_ABORTED',
            'target': 'Build aborted',
            'message': f"Build aborted: {aborted.get('reason', 'UNKNOWN')}",
            'file_location': None,
            'line_number': None
        }
    
    def _find_target_label(self, event_dict: Dict) -> str:
        """Find target label from event data."""
        strings = event_dict.get('_strings', [])
        for s in strings:
            if s.startswith('//'):
                # Clean up the target label
                clean_label = s.strip('",;()[]{}')
                if ':' in clean_label or clean_label.count('/') >= 2:
                    return clean_label
        return 'unknown'
    
    def _extract_error_message_from_strings(self, strings: List[str]) -> str:
        """Extract error message from string list."""
        error_keywords = ['error', 'failed', 'Error', 'Failed', 'compilation', 'undefined']
        error_lines = []
        
        for s in strings:
            if any(keyword in s for keyword in error_keywords) and len(s) > 10:
                # Truncate very long lines
                if len(s) > self.MAX_MESSAGE_SIZE // 5:  # Allow up to 5 lines
                    s = s[:self.MAX_MESSAGE_SIZE // 5] + "... (truncated)"
                error_lines.append(s)
            
            # Stop if we have enough lines
            if len(error_lines) >= self.MAX_ERROR_LINES:
                break
        
        message = '\n'.join(error_lines[:self.MAX_ERROR_LINES])
        
        # Ensure total message doesn't exceed limit
        if len(message) > self.MAX_MESSAGE_SIZE:
            message = message[:self.MAX_MESSAGE_SIZE] + "... (truncated)"
        
        return message
    
    def _extract_file_location_from_strings(self, strings: List[str]) -> tuple:
        """Extract file location and line number from strings."""
        import re
        
        file_patterns = [
            r'([a-zA-Z0-9_/\-\.]+\.(?:cc|cpp|h|hpp|py|java|go|js|ts|kt|scala|rs|c|C|cxx)):(\d+)',
            r'(BUILD(?:\.bazel)?):(\d+)',
            r'(WORKSPACE(?:\.bazel)?):(\d+)'
        ]
        
        for s in strings:
            for pattern in file_patterns:
                match = re.search(pattern, s)
                if match:
                    return match.group(1), int(match.group(2))
        
        return None, None
    
    def _parse_string_event(self, message_data: bytes) -> Optional[Dict[str, Any]]:
        """Fallback string-based parsing when protobuf libraries aren't available."""
        try:
            # Look for failure indicators in the raw message
            message_str = message_data.decode('utf-8', errors='ignore')
            
            # Pattern matching for actual build failures (be more specific)
            failure_patterns = [
                'FAILED_TO_BUILD',
                'COMPILATION_FAILED', 
                'TEST_FAILED',
                'BUILD_FAILED',
                'FAILED TARGETS',
                'COMPILATION ERROR',
                '"status": "FAILED"',  # Test failures
                'testFailureMessage'   # Test failure messages
            ]
            
            # Only look for failures in specific contexts, not in command-line args
            if any(pattern in message_str for pattern in failure_patterns):
                # Additional validation: make sure this looks like an actual failure event
                # Skip if it looks like command-line arguments or configuration
                if ('--client_env' in message_str or 
                    '--default_override' in message_str or
                    'connect_timeout_secs' in message_str or
                    'fatal_event_bus_exceptions' in message_str):
                    return None
            
            for pattern in failure_patterns:
                if pattern in message_str:
                    return self._extract_failure_details(message_str, pattern)
                    
        except Exception as e:
            if self.verbose:
                print(f"Warning: Error parsing message: {e}")
                
        return None
    
    def _extract_failure_details(self, message_str: str, failure_type: str) -> Dict[str, Any]:
        """Extract failure details from message string."""
        # Normalize failure type for better display
        normalized_type = failure_type
        if failure_type == '"status": "FAILED"':
            normalized_type = 'TEST_FAILED'
        elif failure_type == 'testFailureMessage':
            normalized_type = 'TEST_FAILED'
            
        failure = {
            'type': 'build_failure',
            'status': normalized_type,
            'target': 'unknown',
            'message': '',
            'file_location': None,
            'line_number': None
        }
        
        # Try to extract target information with better patterns
        lines = message_str.split('\n')
        target_found = False
        
        # Look for Bazel target patterns (avoid URLs)
        target_patterns = [
            # Full target like //pkg/sub:target - must have colon and valid package chars
            r'//[a-zA-Z0-9_\-][a-zA-Z0-9_/\-]*:[a-zA-Z0-9_\-]+',
            # Root target like //:target - colon required  
            r'//:[a-zA-Z0-9_\-]+',
        ]
        
        import re
        for line in lines:
            for pattern in target_patterns:
                matches = re.findall(pattern, line)
                if matches:
                    failure['target'] = matches[0].strip('"\'')
                    target_found = True
                    break
            if target_found:
                break
        
        # If no target found, try simpler patterns (avoid URLs)
        if not target_found:
            for line in lines:
                if '//' in line:
                    # Look for anything that starts with // but isn't a URL
                    parts = line.split()
                    for part in parts:
                        if part.startswith('//'):
                            clean_part = part.strip('",;()[]{}')
                            # Skip URLs (contain dots) and ensure it looks like a target
                            if (len(clean_part) > 2 and 
                                '.' not in clean_part and 
                                not clean_part.startswith('//http') and
                                not clean_part.startswith('//www')):
                                failure['target'] = clean_part
                                target_found = True
                                break
                if target_found:
                    break
        
        # Extract file locations and line numbers
        file_location_patterns = [
            # Pattern like: "path/to/file.cc:123:45: error message"
            r'([a-zA-Z0-9_/\-\.]+\.(?:cc|cpp|h|hpp|py|java|go|js|ts|kt|scala|rs|c|C|cxx)):(\d+):(?:\d+:)?\s*(.+)',
            # Pattern like: "path/to/file.py:42: message" 
            r'([a-zA-Z0-9_/\-\.]+\.(?:cc|cpp|h|hpp|py|java|go|js|ts|kt|scala|rs|c|C|cxx)):(\d+):\s*(.+)',
            # BUILD file pattern: "BUILD:15:1: message"
            r'(BUILD(?:\.bazel)?):(\d+):(?:\d+:)?\s*(.+)',
            # Workspace file pattern
            r'(WORKSPACE(?:\.bazel)?):(\d+):(?:\d+:)?\s*(.+)',
        ]
        
        import re
        for line in lines:
            for pattern in file_location_patterns:
                match = re.search(pattern, line)
                if match:
                    failure['file_location'] = match.group(1)
                    failure['line_number'] = int(match.group(2))
                    # Use the error message from the match if we don't have one
                    if not failure['message']:
                        failure['message'] = match.group(3).strip()
                    break
            if failure['file_location']:  # Found a file location, stop searching
                break

        # Extract error message with better filtering (if we don't have one from file location)
        if not failure['message']:
            error_lines = []
            relevant_keywords = ['error', 'failed', 'exception', 'timeout', 'compilation']
            
            for line in lines:
                line_lower = line.lower()
                if any(word in line_lower for word in relevant_keywords):
                    # Skip very short or uninformative lines
                    if len(line.strip()) > 10 and not line.strip().startswith('#'):
                        # Truncate very long lines
                        line_text = line.strip()
                        if len(line_text) > self.MAX_MESSAGE_SIZE // self.MAX_ERROR_LINES:
                            line_text = line_text[:self.MAX_MESSAGE_SIZE // self.MAX_ERROR_LINES] + "... (truncated)"
                        error_lines.append(line_text)
                
                # Stop if we have enough lines
                if len(error_lines) >= self.MAX_ERROR_LINES:
                    break
            
            if error_lines:
                message = '\n'.join(error_lines[:self.MAX_ERROR_LINES])
                # Ensure total message doesn't exceed limit
                if len(message) > self.MAX_MESSAGE_SIZE:
                    message = message[:self.MAX_MESSAGE_SIZE] + "... (truncated)"
                failure['message'] = message
            elif failure_type in message_str:
                # Fallback: include the line with the failure type
                for line in lines:
                    if failure_type in line and len(line.strip()) > 10:
                        failure_msg = line.strip()
                        if len(failure_msg) > self.MAX_MESSAGE_SIZE:
                            failure_msg = failure_msg[:self.MAX_MESSAGE_SIZE] + "... (truncated)"
                        failure['message'] = failure_msg
                        break
        
        return failure


class BuildkiteAnnotator:
    """Creates Buildkite annotations from failure analysis."""
    
    def __init__(self):
        # Check for Buildkite environment using multiple indicators
        self.is_buildkite = (
            os.getenv('BUILDKITE') == 'true' or 
            os.getenv('BUILDKITE_BUILD_ID') is not None or
            os.getenv('BUILDKITE_JOB_ID') is not None
        )
        
        # Get repository information for GitHub links
        self.repo_url = self._get_repo_url()
        self.commit_sha = self._get_commit_sha()
        
    def _get_repo_url(self) -> Optional[str]:
        """Get the GitHub repository URL."""
        # Try Buildkite environment first
        buildkite_repo = os.getenv('BUILDKITE_REPO')
        if buildkite_repo:
            # Convert SSH to HTTPS: git@github.com:owner/repo.git -> https://github.com/owner/repo
            if buildkite_repo.startswith('git@github.com:'):
                return buildkite_repo.replace('git@github.com:', 'https://github.com/').rstrip('.git')
            elif buildkite_repo.startswith('https://github.com/'):
                return buildkite_repo.rstrip('.git')
        
        # Fallback: try to get from git remote
        try:
            result = subprocess.run(['git', 'remote', 'get-url', 'origin'], 
                                 capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                remote_url = result.stdout.strip()
                if remote_url.startswith('git@github.com:'):
                    return remote_url.replace('git@github.com:', 'https://github.com/').rstrip('.git')
                elif remote_url.startswith('https://github.com/'):
                    return remote_url.rstrip('.git')
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
        
        return None
    
    def _get_commit_sha(self) -> str:
        """Get the current commit SHA."""
        # Try Buildkite environment first
        commit = os.getenv('BUILDKITE_COMMIT')
        if commit:
            return commit
            
        # Try branch if no commit SHA
        branch = os.getenv('BUILDKITE_BRANCH')
        if branch:
            return branch
            
        # Fallback: try to get from git
        try:
            result = subprocess.run(['git', 'rev-parse', 'HEAD'], 
                                 capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                return result.stdout.strip()
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
            
        return 'main'  # Default fallback
    
    def _create_github_link(self, file_path: str, line_number: Optional[int] = None) -> Optional[str]:
        """Create a GitHub link to a file and line number."""
        if not self.repo_url or not file_path:
            return None
            
        # Clean up file path (remove leading ./ or workspace prefixes)
        clean_path = file_path.lstrip('./')
        
        github_url = f"{self.repo_url}/blob/{self.commit_sha}/{clean_path}"
        
        if line_number:
            github_url += f"#L{line_number}"
            
        return github_url
        
    def create_failure_annotation(self, failures: List[Dict[str, Any]], verbose: bool = False):
        """Create a focused Buildkite annotation for failures."""
        if not failures:
            if verbose:
                print("No failures to annotate")
            return
            
        # Generate annotation content
        annotation_content = self._generate_annotation_content(failures)
        
        if self.is_buildkite:
            self._create_buildkite_annotation(annotation_content, verbose)
        else:
            # Not in Buildkite, just print the annotation
            print("=" * 60)
            print("BUILDKITE ANNOTATION PREVIEW:")
            print("=" * 60)
            print(annotation_content)
            print("=" * 60)
    
    def _generate_annotation_content(self, failures: List[Dict[str, Any]]) -> str:
        """Generate the annotation content."""
        failure_count = len(failures)
        
        content = f"""### üö® Build Failures ({failure_count} found)

"""
        
        # Group failures by type
        failure_types = {}
        for failure in failures:
            failure_type = failure.get('type', 'unknown')
            if failure_type not in failure_types:
                failure_types[failure_type] = []
            failure_types[failure_type].append(failure)
        
        # Display failures by type
        for failure_type, type_failures in failure_types.items():
            content += f"#### {self._get_failure_emoji(failure_type)} {failure_type.replace('_', ' ').title()} ({len(type_failures)})\n\n"
            
            for failure in type_failures:
                target = failure.get('target', 'Unknown target')
                status = failure.get('status', 'FAILED')
                message = failure.get('message', '')
                file_location = failure.get('file_location')
                line_number = failure.get('line_number')
                
                content += f"**Target:** `{target}`  \n"
                content += f"**Status:** {status}  \n"
                
                # Add GitHub link if we have file location
                if file_location:
                    github_link = self._create_github_link(file_location, line_number)
                    if github_link:
                        display_location = f"{file_location}:{line_number}" if line_number else file_location
                        content += f"**File:** [{display_location}]({github_link})  \n"
                    else:
                        display_location = f"{file_location}:{line_number}" if line_number else file_location
                        content += f"**File:** `{display_location}`  \n"
                
                if message:
                    # Clean up the message
                    clean_message = self._clean_error_message(message)
                    content += f"**Error:**\n```\n{clean_message}\n```\n\n"
                else:
                    content += "\n"
        
        content += "---\n"
        content += "*Generated by Bazel Failure Analyzer*\n"
        
        return content
    
    def _get_failure_emoji(self, failure_type: str) -> str:
        """Get appropriate emoji for failure type."""
        emoji_map = {
            'build_failure': 'üî®',
            'test_failure': 'üß™',
            'compilation_failure': '‚öôÔ∏è',
            'timeout': '‚è±Ô∏è',
            'unknown': '‚ùì'
        }
        return emoji_map.get(failure_type, '‚ùå')
    
    def _clean_error_message(self, message: str) -> str:
        """Clean up error message for display."""
        # Remove excessive whitespace
        lines = [line.strip() for line in message.split('\n') if line.strip()]
        
        # Limit to reasonable length
        max_lines = 15  # Allow a bit more for display
        if len(lines) > max_lines:
            lines = lines[:max_lines] + ['... (truncated)']
        
        # Ensure total length is reasonable for annotations
        result = '\n'.join(lines)
        max_annotation_size = 10000  # 10KB limit for Buildkite annotations
        if len(result) > max_annotation_size:
            result = result[:max_annotation_size] + '\n... (truncated for display)'
        
        return result
    
    def _create_buildkite_annotation(self, content: str, verbose: bool = False):
        """Create actual Buildkite annotation."""
        try:
            # Use step ID as context so each step gets its own annotation
            context = os.getenv('BUILDKITE_STEP_ID', 'bazel-failures')
            
            # Use buildkite-agent to create annotation
            cmd = [
                'buildkite-agent', 'annotate',
                '--style', 'error',
                '--context', context
            ]
            
            if verbose:
                print(f"Creating Buildkite annotation with command: {' '.join(cmd)}")
            
            result = subprocess.run(
                cmd,
                input=content,
                text=True,
                capture_output=True,
                check=True
            )
            
            if verbose:
                print("‚úÖ Buildkite annotation created successfully")
                
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Failed to create Buildkite annotation: {e}")
            if verbose:
                print(f"stdout: {e.stdout}")
                print(f"stderr: {e.stderr}")
        except FileNotFoundError:
            print("‚ùå buildkite-agent not found - not running in Buildkite?")
            if verbose:
                print("Annotation content would be:")
                print(content)


def main():
    parser = argparse.ArgumentParser(
        description="Analyze Bazel BEP protobuf files for failures"
    )
    parser.add_argument(
        "bep_file",
        help="Path to the BEP protobuf file"
    )
    parser.add_argument(
        "--output-format",
        choices=["buildkite", "json", "text"],
        default="buildkite",
        help="Output format (default: buildkite)"
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    parser.add_argument(
        "--skip-if-no-failures",
        action="store_true",
        help="Exit successfully if no failures found"
    )
    parser.add_argument(
        "--max-failures",
        type=int,
        default=50,
        help="Maximum number of failures to collect (default: 50)"
    )
    parser.add_argument(
        "--max-file-size",
        type=int,
        default=100,
        help="Maximum file size to process in MB (default: 100)"
    )
    
    args = parser.parse_args()
    
    # Check protobuf availability
    if args.verbose:
        if PROTOBUF_AVAILABLE:
            print("‚úÖ Using enhanced protobuf parsing")
        else:
            print("‚ö†Ô∏è  Protobuf library not available, using fallback string parsing")
            print("   Install with: pip install protobuf")
    
    # Check if BEP file exists
    if not os.path.exists(args.bep_file):
        print(f"‚ùå Error: BEP file not found: {args.bep_file}", file=sys.stderr)
        return 1
    
    if args.verbose:
        print(f"üîç Analyzing BEP file: {args.bep_file}")
    
    try:
        # Initialize analyzer with custom limits
        analyzer = BEPAnalyzer(verbose=args.verbose)
        analyzer.MAX_FAILURES = args.max_failures
        analyzer.MAX_FILE_SIZE = args.max_file_size * 1024 * 1024  # Convert MB to bytes
        
        # Parse BEP file
        failures = analyzer.extract_failures(args.bep_file)
        
        if not failures:
            if args.verbose:
                print("‚úÖ No failures found in BEP file")
            if args.skip_if_no_failures:
                return 0
            else:
                print("‚úÖ Build completed successfully - no failures detected")
                return 0
        
        # Generate output based on format
        if args.output_format == "buildkite":
            annotator = BuildkiteAnnotator()
            annotator.create_failure_annotation(failures, verbose=args.verbose)
        elif args.output_format == "json":
            import json
            print(json.dumps(failures, indent=2))
        else:  # text
            print(f"üö® Found {len(failures)} failures:")
            for i, failure in enumerate(failures, 1):
                print(f"\n{i}. {failure.get('target', 'Unknown target')}")
                print(f"   Type: {failure.get('type', 'Unknown')}")
                print(f"   Status: {failure.get('status', 'FAILED')}")
                if failure.get('message'):
                    print(f"   Message: {failure['message']}")
        
        return 1 if failures else 0
        
    except Exception as e:
        print(f"‚ùå Error analyzing BEP file: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
